// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  window.Knockback = {};

  Knockback.objectReferenceFor = function(className) {
    var components, identifier, namespace;
    namespace = window;
    components = className.split('.');
    while (identifier = components.shift()) {
      namespace = namespace[identifier];
    }
    return namespace;
  };

  Knockback.Relation = (function() {
    function Relation(config) {
      if (config == null) {
        config = {};
      }
      if (!config.name) {
        throw "you must specify a relation's 'name' property";
      }
      if (!config.sourceClass) {
        throw "you must specify a relation's 'sourceClass' property";
      }
      if (!config.target) {
        throw "you must specify a relation's 'target' property";
      }
      this.name = config.name;
      this.target = config.target;
      this.sourceClass = config.sourceClass;
      this.displayName = config.displayName;
      this.inverse = config.inverse;
    }

    Relation.prototype.sourceConstructor = function() {
      var constructor;
      constructor = Knockback.objectReferenceFor(this.sourceClass);
      if (!constructor) {
        throw "sourceClass '" + this.sourceClass + "' is not defined";
      }
      return constructor;
    };

    Relation.prototype.ref = function() {
      var nestedAttrs, source;
      if (this._cached) {
        return this._cached;
      }
      nestedAttrs = this.target.get(this.name);
      source = new (this.sourceConstructor());
      if (source.attributes) {
        this._sourceModel(source, nestedAttrs);
      } else if (source.models) {
        this._sourceCollection(source, nestedAttrs);
      }
      return this._cached = source;
    };

    Relation.prototype._sourceModel = function(source, attrs) {
      source.set(attrs);
      return this.target["" + this.name + "_display"](source);
    };

    Relation.prototype._sourceCollection = function(source, models) {
      var display;
      display = this.target["" + this.name + "_display"];
      source.bind('reset', function() {
        return display(source.models);
      });
      source.bind('remove', function() {
        return display(source.models);
      });
      source.bind('add', function() {
        display(source.models);
        return display.sort(function(m1, m2) {
          if (m1.position) {
            return m1.position() - m2.position();
          }
        });
      });
      if (models) {
        return source.reset(models);
      }
    };

    return Relation;

  })();

  Knockback.Model = Backbone.Model.extend({
    initialize: function(attrs, options) {
      attrs = attrs !== void 0 ? attrs : {};
      options = options !== void 0 ? options : {};
      this._bindProxiedMethods();
      this._initRelations(attrs, options);
      return this._initAttributes(attrs, options);
    },
    set: function(attrs, options) {
      var _this = this;
      if (!Backbone.Model.prototype.set.apply(this, [attrs, options])) {
        return false;
      }
      if (this._relationsInitialized) {
        _.each(attrs, function(value, key) {
          var relation;
          if (_this.relations[key] && _this[key]) {
            relation = _this[key].ref(true);
            if (relation.set) {
              return relation.set(value, options);
            } else if (relation.reset) {
              return relation.reset(value, options);
            }
          }
        });
      }
      return this;
    },
    includeObservables: function() {
      var obj, objs,
        _this = this;
      objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      obj = _.extend.apply(_, [{}].concat(__slice.call(objs)));
      return _.each(_.functions(obj), function(method) {
        if (_this[method]) {
          throw "dependentObservable would overwrite existing property or method: '" + method + "'";
        }
        return _this[method] = ko.dependentObservable(obj[method], _this, {
          deferEvaluation: true
        });
      });
    },
    parse: function(response, xhr) {
      var responseAttrs,
        _this = this;
      if (this.ajaxPrefix) {
        responseAttrs = response[this.ajaxPrefix];
        _.each(this.relations, function(className, relationName) {
          if (response[relationName] && !responseAttrs[relationName]) {
            return responseAttrs[relationName] = response[relationName];
          }
        });
        return responseAttrs;
      } else {
        return response;
      }
    },
    _bindProxiedMethods: function() {
      var proxiedFunctions,
        _this = this;
      proxiedFunctions = _.select(this.proxied || [], function(methodName) {
        return _.isFunction(_this[methodName]);
      });
      if (proxiedFunctions.length > 0) {
        return _.bindAll.apply(_, [this].concat(__slice.call(proxiedFunctions)));
      }
    },
    _initAttributes: function(attrs, options) {
      var allAttrs, newAttrs,
        _this = this;
      this.observables = this.observables || {};
      newAttrs = {};
      this.ID = ko.observable(attrs[this.idAttribute] || null);
      this.bind("change:" + this.idAttribute, function(model, newId) {
        return _this.ID(newId);
      });
      _.each(this.observables, function(value, key) {
        var safeValue;
        safeValue = attrs[key] ? attrs[key] : value && typeof value === 'object' ? _.clone(value) : value;
        if (!_.isFunction(value)) {
          return newAttrs[key] = safeValue;
        }
      });
      allAttrs = _.extend(newAttrs, attrs);
      _.each(allAttrs, function(value, key) {
        if (!_this._wouldOverwriteExistingProperty(key, !!_this.observables[key])) {
          return _this._initObservable(key, value);
        }
      });
      _.each(_.functions(this.observables), function(methodName) {
        if (!_this[methodName]) {
          throw "cannot create dependentObservable because model has no method '" + methodName + "'";
        }
        if (Knockback.Model.prototype[methodName]) {
          throw "dependentObservable would override base class method '" + methodName + "'";
        }
        return _this[methodName] = ko.dependentObservable(_this[methodName], _this, {
          deferEvaluation: true
        });
      });
      return this.set(allAttrs, options);
    },
    _initObservable: function(key, value) {
      var _this = this;
      this[key] = _.isArray(value) ? ko.observableArray(value) : ko.observable(value);
      this.bind("change:" + key, function(model, newValue) {
        return _this[key](newValue);
      });
      return this[key].subscribe(function(newValue) {
        var h;
        h = {};
        h[key] = newValue;
        return _this.set(h);
      });
    },
    _wouldOverwriteExistingProperty: function(key, raiseOnError) {
      if (raiseOnError == null) {
        raiseOnError = true;
      }
      if (key === this.idAttribute) {
        if (raiseOnError) {
          throw "you cannot make the '" + this.idAttribute + "' observable because it is the idAttribute";
        }
        return true;
      } else if (this[key]) {
        if (raiseOnError) {
          throw "observable attribute '" + key + "' would overwrite an existing property or method";
        }
        return true;
      } else {
        return false;
      }
    },
    _initRelations: function(attrs, options) {
      var _this = this;
      this.relations = this.relations || {};
      _.each(this.relations, function(className, relationName) {
        var klass, relation;
        if (_this[relationName]) {
          throw "relation '" + relationName + "' would overwrite an existing property or method";
        }
        relation = _this[relationName] = new Knockback.Relation({
          name: relationName,
          sourceClass: className,
          target: _this
        });
        klass = relation.sourceConstructor();
        if (klass.prototype.reset) {
          return _this["" + relationName + "_observable"] = ko.observableArray();
        } else if (klass.prototype.isNew) {
          return _this["" + relationName + "_observable"] = ko.observable({});
        }
      });
      return this._relationsInitialized = true;
    }
  });

  Knockback.Collection = Backbone.Collection.extend;

  Knockback.Controller = Backbone.Router.extend({
    initialize: function(options) {
      var _this = this;
      options = options !== void 0 ? options : {};
      this._wrapped = {};
      return _.each(this.routes, function(name, pattern) {
        var handler;
        handler = _this.handlerForRoute(name);
        if (handler && !_this._wrapped[name]) {
          return handler.callback = _this._wrapped[name] = _.wrap(handler.callback, function(callback, urlFragment) {
            return _this.actionWithFilters(name, callback, urlFragment);
          });
        }
      });
    },
    inverseRoutes: function() {
      var _this = this;
      return this._inverseRoutes || (this._inverseRoutes = _.reduce(this.routes, (function(memo, name, pattern) {
        memo[name] = _this._routeToRegExp(pattern).toString();
        return memo;
      }), {}));
    },
    handlerForRoute: function(routeName) {
      var handlers, routeExp;
      routeExp = this.inverseRoutes()[routeName];
      handlers = Backbone.history ? Backbone.history.handlers : [];
      return _.detect(handlers, function(handler) {
        return handler.route.toString() === routeExp;
      });
    },
    actionWithFilters: function(name, action, urlFragment) {
      var _this = this;
      _.each(this.filtersForAction(name, 'before'), function(filter) {
        return filter.apply(_this, [urlFragment]);
      });
      action(urlFragment);
      return _.each(this.filtersForAction(name, 'after'), function(filter) {
        return filter.apply(_this, [urlFragment]);
      });
    },
    filtersForAction: function(actionName, filterType) {
      var action_filters, global_filters, methodNames,
        _this = this;
      if (!this.inverseRoutes()[actionName]) {
        throw "cannot run filters for non-existent action, '" + actionName + "'";
      }
      this.filters || (this.filters = {});
      global_filters = this.filters[filterType] || [];
      action_filters = this.filters["" + filterType + "_" + actionName] || [];
      methodNames = [].concat(global_filters, action_filters);
      return _.map(methodNames, function(methodName) {
        return _this[methodName];
      });
    }
  });

}).call(this);
