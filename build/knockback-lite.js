// Generated by CoffeeScript 1.3.1
(function() {
  var __slice = [].slice;

  window.Knockback = {};

  Knockback.Model = Backbone.Model.extend({
    initialize: function(attrs, options) {
      attrs = typeof attrs !== 'undefined' ? attrs : {};
      options = typeof options !== 'undefined' ? options : {};
      return this._initAttributes(attrs, options);
    },
    set: function(attrs, options) {
      attrs = typeof attrs !== 'undefined' ? attrs : {};
      options = typeof options !== 'undefined' ? options : {};
      var _this = this;
      if (!Backbone.Model.prototype.set.apply(this, [attrs, options])) {
        return false;
      }
      return this;
    },
    includeObservables: function() {
      var obj, objs,
        _this = this;
      objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      obj = _.extend.apply(_, [{}].concat(__slice.call(objs)));
      return _.each(_.functions(obj), function(method) {
        if (_this[method]) {
          throw "dependentObservable would overwrite existing property or method: '" + method + "'";
        }
        return _this[method] = ko.dependentObservable(obj[method], _this, {
          deferEvaluation: true
        });
      });
    },
    parse: function(response, xhr) {
      var responseAttrs,
        _this = this;
      if (this.ajaxPrefix) {
        responseAttrs = response[this.ajaxPrefix];
        return responseAttrs;
      } else {
        return response;
      }
    },
    _initAttributes: function(attrs, options) {
      var allAttrs, newAttrs,
        _this = this;
      this.observables = this.observables || {};
      newAttrs = {};
      this.ID = ko.observable(attrs[this.idAttribute] || null);
      this.bind("change:" + this.idAttribute, function(model, newId) {
        return _this.ID(newId);
      });
      _.each(this.observables, function(value, key) {
        var safeValue;
        safeValue = attrs[key] ? attrs[key] : value && typeof value === 'object' ? _.clone(value) : value;
        if (!_.isFunction(value)) {
          return newAttrs[key] = safeValue;
        }
      });
      allAttrs = _.extend(newAttrs, attrs);
      _.each(allAttrs, function(value, key) {
        if (!_this._wouldOverwriteExistingProperty(key, !!_this.observables[key])) {
          return _this._initObservable(key, value);
        }
      });
      _.each(_.functions(this.observables), function(methodName) {
        if (!_this[methodName]) {
          throw "cannot create dependentObservable because model has no method '" + methodName + "'";
        }
        if (Knockback.Model.prototype[methodName]) {
          throw "dependentObservable would override base class method '" + methodName + "'";
        }
        return _this[methodName] = ko.dependentObservable(_this[methodName], _this, {
          deferEvaluation: true
        });
      });
      return this.set(allAttrs, options);
    },
    _initObservable: function(key, value) {
      var _this = this;
      this[key] = _.isArray(value) ? ko.observableArray(value) : ko.observable(value);
      this.bind("change:" + key, function(model, newValue) {
        return _this[key](newValue);
      });
      return this[key].subscribe(function(newValue) {
        var h;
        h = {};
        h[key] = newValue;
        return _this.set(h);
      });
    },
    _wouldOverwriteExistingProperty: function(key, raiseOnError) {
      if (raiseOnError == null) {
        raiseOnError = true;
      }
      if (key === this.idAttribute) {
        if (raiseOnError) {
          throw "you cannot make the '" + this.idAttribute + "' observable because it is the idAttribute";
        }
        return true;
      } else if (this[key]) {
        if (raiseOnError) {
          throw "observable attribute '" + key + "' would overwrite an existing property or method";
        }
        return true;
      } else {
        return false;
      }
    }
  });


}).call(this);
